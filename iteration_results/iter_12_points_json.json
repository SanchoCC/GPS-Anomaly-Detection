{
  "iteration": 12,
  "timestamp": "2025-07-15T17:53:14.876754",
  "compile_success": false,
  "anomaly_detected": false,
  "correction_success": false,
  "execution_time": 0.0,
  "algorithm_code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n\n// Simple JSON parsing utilities for the specific input format\nstruct Point {\n    int lat;\n    int lon;\n    int time;\n};\n\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\n// Haversine formula to compute distance between two lat/lon points in meters\ndouble haversine(int lat1, int lon1, int lat2, int lon2) {\n    const double R = 6371000.0; // Earth radius in meters\n    double dLat = deg2rad(lat2 / 1e7 - lat1 / 1e7);\n    double dLon = deg2rad(lon2 / 1e7 - lon1 / 1e7);\n    double a = std::sin(dLat / 2) * std::sin(dLat / 2) +\n               std::cos(deg2rad(lat1 / 1e7)) * std::cos(deg2rad(lat2 / 1e7)) *\n               std::sin(dLon / 2) * std::sin(dLon / 2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1 - a));\n    return R * c;\n}\n\n// Reads entire stdin into a string\nstd::string read_stdin() {\n    std::ostringstream oss;\n    oss << std::cin.rdbuf();\n    return oss.str();\n}\n\n// Trims whitespace from both ends of a string\nstd::string trim(const std::string& s) {\n    size_t start = 0;\n    while (start < s.size() && std::isspace(static_cast<unsigned char>(s[start]))) ++start;\n    size_t end = s.size();\n    while (end > start && std::isspace(static_cast<unsigned char>(s[end - 1]))) --end;\n    return s.substr(start, end - start);\n}\n\n// Parses a JSON array of {\"lat\":..., \"lon\":..., \"time\":...} objects\nstd::vector<Point> parse_json_points(const std::string& input) {\n    std::vector<Point> points;\n    size_t i = 0;\n    while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n    if (i == input.size() || input[i] != '[')\n        throw std::runtime_error(\"JSON must start with '['\");\n    ++i;\n    while (i < input.size()) {\n        // Skip whitespace and commas\n        while (i < input.size() && (std::isspace(static_cast<unsigned char>(input[i])) || input[i] == ',')) ++i;\n        if (i == input.size()) break;\n        if (input[i] == ']') break;\n        // Parse object\n        if (input[i] != '{')\n            throw std::runtime_error(\"Expected '{' at start of object\");\n        ++i;\n        int lat = std::numeric_limits<int>::min(), lon = std::numeric_limits<int>::min(), time = std::numeric_limits<int>::min();\n        bool lat_set = false, lon_set = false, time_set = false;\n        while (i < input.size()) {\n            // Skip whitespace\n            while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n            if (i == input.size()) throw std::runtime_error(\"Unexpected end of input in object\");\n            if (input[i] == '}') {\n                ++i;\n                break;\n            }\n            // Parse key\n            if (input[i] != '\"') throw std::runtime_error(\"Expected '\\\"' at start of key\");\n            ++i;\n            size_t key_start = i;\n            while (i < input.size() && input[i] != '\"') ++i;\n            if (i == input.size()) throw std::runtime_error(\"Unterminated key string\");\n            std::string key = input.substr(key_start, i - key_start);\n            ++i;\n            // Skip whitespace\n            while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n            if (i == input.size() || input[i] != ':') throw std::runtime_error(\"Expected ':' after key\");\n            ++i;\n            // Skip whitespace\n            while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n            // Parse value\n            size_t val_start = i;\n            bool negative = false;\n            if (input[i] == '-') { negative = true; ++i; }\n            if (!std::isdigit(static_cast<unsigned char>(input[i])))\n                throw std::runtime_error(\"Expected digit in value\");\n            int value = 0;\n            while (i < input.size() && std::isdigit(static_cast<unsigned char>(input[i]))) {\n                value = value * 10 + (input[i] - '0');\n                ++i;\n            }\n            if (negative) value = -value;\n            if (key == \"lat\") { lat = value; lat_set = true; }\n            else if (key == \"lon\") { lon = value; lon_set = true; }\n            else if (key == \"time\") { time = value; time_set = true; }\n            else throw std::runtime_error(\"Unknown key: \" + key);\n            // Skip whitespace\n            while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n            // If next is ',', skip and continue, else expect '}'\n            if (i < input.size() && input[i] == ',') ++i;\n        }\n        if (!(lat_set && lon_set && time_set))\n            throw std::runtime_error(\"Missing lat/lon/time in object\");\n        points.push_back(Point{lat, lon, time});\n        // Skip whitespace and commas\n        while (i < input.size() && (std::isspace(static_cast<unsigned char>(input[i])) || input[i] == ',')) ++i;\n        if (i < input.size() && input[i] == ']') break;\n    }\n    // Final check for closing ']'\n    while (i < input.size() && std::isspace(static_cast<unsigned char>(input[i]))) ++i;\n    if (i == input.size() || input[i] != ']')\n        throw std::runtime_error(\"JSON array not properly closed with ']'\");\n    return points;\n}\n\n// Outputs points as a JSON array\nvoid output_json_points(const std::vector<Point>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << points[i].lat\n                  << \",\\\"lon\\\":\" << points[i].lon\n                  << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\" << std::endl;\n}\n\n// Detects anomalies: returns true if the point at idx is anomalous (speed > 50 m/s)\nbool is_anomalous(const std::vector<Point>& pts, size_t idx) {\n    if (idx == 0 || idx + 1 >= pts.size()) return false;\n    int dt1 = pts[idx].time - pts[idx-1].time;\n    int dt2 = pts[idx+1].time - pts[idx].time;\n    if (dt1 <= 0 || dt2 <= 0) return false;\n    double d1 = haversine(pts[idx-1].lat, pts[idx-1].lon, pts[idx].lat, pts[idx].lon);\n    double d2 = haversine(pts[idx].lat, pts[idx].lon, pts[idx+1].lat, pts[idx+1].lon);\n    double v1 = d1 / dt1;\n    double v2 = d2 / dt2;\n    return (v1 > 50.0) || (v2 > 50.0);\n}\n\n// Corrects anomalous point at idx by linear interpolation between neighbors\nPoint interpolate(const Point& prev, const Point& next, int time) {\n    double t0 = prev.time, t1 = next.time, t = time;\n    double ratio = (t - t0) / (t1 - t0);\n    int lat = static_cast<int>(std::round(prev.lat + (next.lat - prev.lat) * ratio));\n    int lon = static_cast<int>(std::round(prev.lon + (next.lon - prev.lon) * ratio));\n    return Point{lat, lon, time};\n}\n\nint main() {\n    try {\n        std::string input = read_stdin();\n        input = trim(input);\n        std::vector<Point> points = parse_json_points(input);\n        if (points.size() < 3) {\n            output_json_points(points);\n            return 0;\n        }\n        std::vector<Point> corrected = points;\n        for (size_t i = 1; i + 1 < points.size(); ++i) {\n            if (is_anomalous(points, i)) {\n                // Only correct if not first or last\n                corrected[i] = interpolate(points[i-1], points[i+1], points[i].time);\n            }\n        }\n        output_json_points(corrected);\n    } catch (const std::exception& ex) {\n        // Output empty array on error to maintain JSON format\n        std::cout << \"[]\" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "Validation error: Missing '#define _USE_MATH_DEFINES' required for pattern 'M_PI'",
  "input_file": "points.json",
  "details": {
    "code_size": 7525,
    "compile_time": 0.0,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 0,
    "changed_points": 0,
    "time_mismatches": 0
  }
}