{
  "iteration": 1,
  "timestamp": "2025-07-15T17:48:32.955990",
  "compile_success": false,
  "anomaly_detected": false,
  "correction_success": false,
  "execution_time": 0.0,
  "algorithm_code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <sstream>\n#define _USE_MATH_DEFINES\n\nstruct GPSPoint {\n    int lat; // in 1e-6 degrees\n    int lon; // in 1e-6 degrees\n    int time; // seconds\n    bool anomalous = false;\n    // For interpolation\n    int orig_lat, orig_lon;\n};\n\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\n// Haversine formula to compute distance in meters between two GPS points\ndouble haversine(int lat1, int lon1, int lat2, int lon2) {\n    // Convert to double degrees\n    double dlat = (lat2 - lat1) * 1e-6;\n    double dlon = (lon2 - lon1) * 1e-6;\n    double alat1 = lat1 * 1e-6;\n    double alon1 = lon1 * 1e-6;\n    double alat2 = lat2 * 1e-6;\n    double alon2 = lon2 * 1e-6;\n    double R = 6371000.0; // Earth radius in meters\n    double phi1 = deg2rad(alat1);\n    double phi2 = deg2rad(alat2);\n    double dphi = deg2rad(dlat);\n    double dlambda = deg2rad(dlon);\n    double a = std::sin(dphi/2)*std::sin(dphi/2) +\n               std::cos(phi1)*std::cos(phi2)*std::sin(dlambda/2)*std::sin(dlambda/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Manual JSON parsing for array of {\"lat\":int,\"lon\":int,\"time\":int}\nstd::vector<GPSPoint> parse_json_array(const std::string& s) {\n    std::vector<GPSPoint> points;\n    size_t i = 0, n = s.size();\n    while (i < n && s[i] != '[') ++i;\n    ++i; // skip '['\n    while (i < n) {\n        while (i < n && (s[i] == ' ' || s[i] == ',')) ++i;\n        if (i >= n || s[i] != '{') break;\n        ++i; // skip '{'\n        GPSPoint pt;\n        pt.anomalous = false;\n        pt.orig_lat = pt.orig_lon = 0;\n        // Parse fields\n        for (int f = 0; f < 3; ++f) {\n            while (i < n && (s[i] == ' ' || s[i] == ',')) ++i;\n            // Parse key\n            if (i >= n || s[i] != '\"') break;\n            ++i;\n            std::string key;\n            while (i < n && s[i] != '\"') key += s[i++];\n            ++i; // skip closing '\"'\n            while (i < n && (s[i] == ' ' || s[i] == ':')) ++i;\n            // Parse value\n            int sign = 1;\n            if (i < n && s[i] == '-') { sign = -1; ++i; }\n            int val = 0;\n            while (i < n && std::isdigit(s[i])) {\n                val = val * 10 + (s[i++] - '0');\n            }\n            val *= sign;\n            if (key == \"lat\") pt.lat = val;\n            else if (key == \"lon\") pt.lon = val;\n            else if (key == \"time\") pt.time = val;\n            while (i < n && (s[i] == ' ' || s[i] == ',')) ++i;\n        }\n        while (i < n && s[i] != '}') ++i;\n        ++i; // skip '}'\n        points.push_back(pt);\n        while (i < n && (s[i] == ' ' || s[i] == ',')) ++i;\n        if (i < n && s[i] == ']') break;\n    }\n    return points;\n}\n\n// Output JSON array\nvoid output_json_array(const std::vector<GPSPoint>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << points[i].lat\n                  << \",\\\"lon\\\":\" << points[i].lon\n                  << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\" << std::endl;\n}\n\n// Median absolute deviation (MAD) for robust outlier detection\ndouble median(std::vector<double> v) {\n    if (v.empty()) return 0.0;\n    std::sort(v.begin(), v.end());\n    size_t n = v.size();\n    if (n % 2) return v[n/2];\n    return (v[n/2-1] + v[n/2]) / 2.0;\n}\n\nvoid detect_anomalies(std::vector<GPSPoint>& pts) {\n    const double MAX_SPEED = 50.0; // m/s\n    size_t N = pts.size();\n    if (N < 3) return;\n\n    // Compute segment speeds\n    std::vector<double> speeds(N-1, 0.0);\n    for (size_t i = 1; i < N; ++i) {\n        double dist = haversine(pts[i-1].lat, pts[i-1].lon, pts[i].lat, pts[i].lon);\n        int dt = pts[i].time - pts[i-1].time;\n        if (dt > 0)\n            speeds[i-1] = dist / dt;\n        else\n            speeds[i-1] = 0.0;\n    }\n\n    // Statistical anomaly detection: robust thresholding\n    std::vector<double> speeds_no0;\n    for (auto s : speeds) if (s > 0.1) speeds_no0.push_back(s);\n    double med = median(speeds_no0);\n    std::vector<double> absdev;\n    for (auto s : speeds_no0) absdev.push_back(std::abs(s - med));\n    double mad = median(absdev);\n    double robust_thresh = med + 6 * mad;\n    double threshold = std::max(MAX_SPEED, robust_thresh);\n\n    // Mark anomalous points (only interior points)\n    for (size_t i = 1; i+1 < N; ++i) {\n        double s1 = speeds[i-1];\n        double s2 = speeds[i];\n        bool anomaly = false;\n        // If either segment to or from this point is anomalous\n        if (s1 > threshold || s2 > threshold) anomaly = true;\n        // But only if both segments exist (not first/last)\n        if (anomaly) pts[i].anomalous = true;\n    }\n    pts.front().anomalous = pts.back().anomalous = false;\n}\n\n// Linear interpolation for anomalous points (coordinates only)\nvoid interpolate_anomalies(std::vector<GPSPoint>& pts) {\n    size_t N = pts.size();\n    if (N < 3) return;\n    for (size_t i = 0; i < N; ++i) {\n        pts[i].orig_lat = pts[i].lat;\n        pts[i].orig_lon = pts[i].lon;\n    }\n    // For each anomalous point, find previous and next non-anomalous\n    for (size_t i = 1; i+1 < N; ++i) {\n        if (!pts[i].anomalous) continue;\n        // Find prev\n        size_t prev = i-1;\n        while (prev > 0 && pts[prev].anomalous) --prev;\n        // Find next\n        size_t next = i+1;\n        while (next+1 < N && pts[next].anomalous) ++next;\n        // Only interpolate if both neighbors are non-anomalous and time order is valid\n        if (!pts[prev].anomalous && !pts[next].anomalous &&\n            pts[next].time != pts[prev].time) {\n            double t0 = pts[prev].time, t1 = pts[next].time, t = pts[i].time;\n            double alpha = (t - t0) / (t1 - t0);\n            double lat_interp = pts[prev].lat + alpha * (pts[next].lat - pts[prev].lat);\n            double lon_interp = pts[prev].lon + alpha * (pts[next].lon - pts[prev].lon);\n            pts[i].lat = static_cast<int>(std::round(lat_interp));\n            pts[i].lon = static_cast<int>(std::round(lon_interp));\n        }\n        // If cannot interpolate (e.g. all neighbors anomalous), leave as is\n    }\n}\n\nint main() {\n    // Read entire stdin into a string\n    std::ostringstream oss;\n    std::string line;\n    while (std::getline(std::cin, line)) oss << line;\n    std::string input = oss.str();\n\n    // Parse JSON\n    std::vector<GPSPoint> pts = parse_json_array(input);\n\n    // Detect anomalies\n    detect_anomalies(pts);\n\n    // Interpolate only anomalous points (not first/last)\n    interpolate_anomalies(pts);\n\n    // Output JSON\n    output_json_array(pts);\n\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "COMPILE ERROR:\ncompiled_binaries\\current_iteration.cpp: In function 'double deg2rad(double)':\ncompiled_binaries\\current_iteration.cpp:20:18: error: 'M_PI' was not declared in this scope\n   20 |     return deg * M_PI / 180.0;\n      |                  ^~~~\n",
  "input_file": "points3.json",
  "details": {
    "code_size": 6704,
    "compile_time": 0.8018410205841064,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 0,
    "changed_points": 0,
    "time_mismatches": 0
  }
}