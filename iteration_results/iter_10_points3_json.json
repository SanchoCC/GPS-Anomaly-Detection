{
  "iteration": 10,
  "timestamp": "2025-07-15T17:52:18.278961",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": true,
  "execution_time": 0.06096220016479492,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n\n// Simple JSON parsing utilities (no external dependencies)\nstruct GPSPoint {\n    int lat;\n    int lon;\n    int time;\n};\n\nbool is_digit_or_minus(char c) {\n    return std::isdigit(c) || c == '-';\n}\n\n// Parse a single integer value from a JSON string at the given position\nbool parse_int(const std::string& s, size_t& pos, int& value) {\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    bool neg = false;\n    if (pos < s.size() && s[pos] == '-') {\n        neg = true;\n        ++pos;\n    }\n    if (pos >= s.size() || !std::isdigit(s[pos])) return false;\n    int v = 0;\n    while (pos < s.size() && std::isdigit(s[pos])) {\n        v = v * 10 + (s[pos] - '0');\n        ++pos;\n    }\n    value = neg ? -v : v;\n    return true;\n}\n\n// Parse a key in the form of \"key\":\nbool parse_key(const std::string& s, size_t& pos, std::string& key) {\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    if (pos >= s.size() || s[pos] != '\"') return false;\n    ++pos;\n    size_t start = pos;\n    while (pos < s.size() && s[pos] != '\"') ++pos;\n    if (pos >= s.size()) return false;\n    key = s.substr(start, pos - start);\n    ++pos;\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    if (pos >= s.size() || s[pos] != ':') return false;\n    ++pos;\n    return true;\n}\n\n// Parse a single GPSPoint object from a JSON string at the given position\nbool parse_gps_point(const std::string& s, size_t& pos, GPSPoint& pt) {\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    if (pos >= s.size() || s[pos] != '{') return false;\n    ++pos;\n    bool lat_set = false, lon_set = false, time_set = false;\n    for (int i = 0; i < 3; ++i) {\n        std::string key;\n        if (!parse_key(s, pos, key)) return false;\n        int value;\n        if (!parse_int(s, pos, value)) return false;\n        if (key == \"lat\") {\n            pt.lat = value;\n            lat_set = true;\n        } else if (key == \"lon\") {\n            pt.lon = value;\n            lon_set = true;\n        } else if (key == \"time\") {\n            pt.time = value;\n            time_set = true;\n        } else {\n            return false;\n        }\n        while (pos < s.size() && std::isspace(s[pos])) ++pos;\n        if (i < 2) {\n            if (pos >= s.size() || s[pos] != ',') return false;\n            ++pos;\n        }\n    }\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    if (pos >= s.size() || s[pos] != '}') return false;\n    ++pos;\n    return lat_set && lon_set && time_set;\n}\n\n// Parse the full JSON array of GPS points\nbool parse_gps_array(const std::string& s, std::vector<GPSPoint>& points) {\n    size_t pos = 0;\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    if (pos >= s.size() || s[pos] != '[') return false;\n    ++pos;\n    while (true) {\n        while (pos < s.size() && std::isspace(s[pos])) ++pos;\n        if (pos < s.size() && s[pos] == ']') {\n            ++pos;\n            break;\n        }\n        GPSPoint pt;\n        if (!parse_gps_point(s, pos, pt)) return false;\n        points.push_back(pt);\n        while (pos < s.size() && std::isspace(s[pos])) ++pos;\n        if (pos < s.size() && s[pos] == ',') {\n            ++pos;\n            continue;\n        }\n        if (pos < s.size() && s[pos] == ']') {\n            ++pos;\n            break;\n        }\n    }\n    while (pos < s.size() && std::isspace(s[pos])) ++pos;\n    return pos == s.size();\n}\n\n// Haversine formula to compute distance in meters between two lat/lon points (integers in microdegrees)\ndouble haversine(int lat1, int lon1, int lat2, int lon2) {\n    // Convert to degrees\n    double dlat = (lat2 - lat1) * 1e-6;\n    double dlon = (lon2 - lon1) * 1e-6;\n    double alat1 = lat1 * 1e-6 * M_PI / 180.0;\n    double alat2 = lat2 * 1e-6 * M_PI / 180.0;\n    double dlat_rad = dlat * M_PI / 180.0;\n    double dlon_rad = dlon * M_PI / 180.0;\n    double a = std::sin(dlat_rad/2) * std::sin(dlat_rad/2) +\n               std::cos(alat1) * std::cos(alat2) *\n               std::sin(dlon_rad/2) * std::sin(dlon_rad/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return 6371000.0 * c;\n}\n\n// Detect anomalies: speed > 50 m/s between consecutive points\nstd::vector<bool> detect_anomalies(const std::vector<GPSPoint>& points) {\n    size_t n = points.size();\n    std::vector<bool> is_anomaly(n, false);\n    for (size_t i = 1; i < n; ++i) {\n        int dt = points[i].time - points[i-1].time;\n        if (dt <= 0) continue; // skip invalid time\n        double dist = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double speed = dist / dt;\n        if (speed > 50.0) {\n            is_anomaly[i] = true;\n        }\n    }\n    for (size_t i = 0; i + 1 < n; ++i) {\n        int dt = points[i+1].time - points[i].time;\n        if (dt <= 0) continue;\n        double dist = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double speed = dist / dt;\n        if (speed > 50.0) {\n            is_anomaly[i] = true;\n        }\n    }\n    is_anomaly[0] = false;\n    if (n > 0) is_anomaly[n-1] = false;\n    return is_anomaly;\n}\n\n// Interpolate anomalous points using linear interpolation between previous and next non-anomalous points\nvoid correct_anomalies(std::vector<GPSPoint>& points, const std::vector<bool>& is_anomaly) {\n    size_t n = points.size();\n    if (n < 3) return;\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (!is_anomaly[i]) continue;\n        // Find previous non-anomalous\n        size_t prev = i-1;\n        while (prev > 0 && is_anomaly[prev]) --prev;\n        // Find next non-anomalous\n        size_t next = i+1;\n        while (next + 1 < n && is_anomaly[next]) ++next;\n        if (is_anomaly[prev] || is_anomaly[next]) continue; // can't interpolate\n        int t0 = points[prev].time, t1 = points[next].time, t = points[i].time;\n        if (t1 == t0) continue;\n        double alpha = double(t - t0) / (t1 - t0);\n        int new_lat = int(std::round(points[prev].lat + alpha * (points[next].lat - points[prev].lat)));\n        int new_lon = int(std::round(points[prev].lon + alpha * (points[next].lon - points[prev].lon)));\n        points[i].lat = new_lat;\n        points[i].lon = new_lon;\n        // time remains unchanged\n    }\n}\n\n// Output JSON array in required format\nvoid output_json(const std::vector<GPSPoint>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << points[i].lat\n                  << \",\\\"lon\\\":\" << points[i].lon\n                  << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\nint main() {\n    // Read all input from stdin\n    std::string input, line;\n    while (std::getline(std::cin, line)) {\n        input += line;\n    }\n    std::vector<GPSPoint> points;\n    try {\n        if (!parse_gps_array(input, points)) {\n            std::cerr << \"Invalid JSON input\\n\";\n            return 1;\n        }\n        if (points.size() < 2) {\n            output_json(points);\n            return 0;\n        }\n        std::vector<bool> is_anomaly = detect_anomalies(points);\n        correct_anomalies(points, is_anomaly);\n        output_json(points);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << \"\\n\";\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 7474,
    "compile_time": 1.1998238563537598,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 12,
    "changed_points": 9,
    "time_mismatches": 0,
    "remaining_anomalies": 0,
    "max_speed_violations": 0,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 0
  }
}