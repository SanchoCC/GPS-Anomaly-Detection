{
  "iteration": 15,
  "timestamp": "2025-07-15T17:54:42.009481",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.06082963943481445,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n\nstruct Point {\n    double lat;\n    double lon;\n    int time;\n    bool anomalous = false;\n};\n\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\ndouble haversine(double lat1, double lon1, double lat2, double lon2) {\n    // Earth radius in meters\n    const double R = 6371000.0;\n    double dlat = deg2rad(lat2 - lat1);\n    double dlon = deg2rad(lon2 - lon1);\n    double a = sin(dlat/2) * sin(dlat/2) +\n               cos(deg2rad(lat1)) * cos(deg2rad(lat2)) *\n               sin(dlon/2) * sin(dlon/2);\n    double c = 2 * atan2(sqrt(a), sqrt(1-a));\n    return R * c;\n}\n\n// Minimal JSON parser for array of objects [{\"lat\":123,\"lon\":456,\"time\":789},...]\nbool parse_json_array(const std::string& input, std::vector<Point>& points) {\n    size_t i = 0;\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    if (i >= input.size() || input[i] != '[') return false;\n    ++i;\n    while (i < input.size()) {\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ']') {\n            ++i;\n            break;\n        }\n        if (i >= input.size() || input[i] != '{') return false;\n        ++i;\n        double lat = std::numeric_limits<double>::quiet_NaN();\n        double lon = std::numeric_limits<double>::quiet_NaN();\n        int time = 0;\n        bool lat_set = false, lon_set = false, time_set = false;\n        while (i < input.size()) {\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == '}') {\n                ++i;\n                break;\n            }\n            // Parse key\n            if (i >= input.size() || input[i] != '\"') return false;\n            ++i;\n            size_t key_start = i;\n            while (i < input.size() && input[i] != '\"') ++i;\n            if (i >= input.size()) return false;\n            std::string key = input.substr(key_start, i - key_start);\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i >= input.size() || input[i] != ':') return false;\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            // Parse value\n            size_t val_start = i;\n            if (key == \"lat\" || key == \"lon\") {\n                bool neg = false;\n                if (i < input.size() && input[i] == '-') { neg = true; ++i; }\n                double val = 0.0;\n                bool has_dot = false;\n                double frac = 0.1;\n                while (i < input.size() && (std::isdigit(input[i]) || input[i] == '.')) {\n                    if (input[i] == '.') {\n                        if (has_dot) return false;\n                        has_dot = true;\n                        ++i;\n                        continue;\n                    }\n                    if (!has_dot) {\n                        val = val * 10 + (input[i] - '0');\n                    } else {\n                        val += (input[i] - '0') * frac;\n                        frac *= 0.1;\n                    }\n                    ++i;\n                }\n                if (neg) val = -val;\n                if (key == \"lat\") { lat = val; lat_set = true; }\n                else { lon = val; lon_set = true; }\n            } else if (key == \"time\") {\n                bool neg = false;\n                if (i < input.size() && input[i] == '-') { neg = true; ++i; }\n                int val = 0;\n                while (i < input.size() && std::isdigit(input[i])) {\n                    val = val * 10 + (input[i] - '0');\n                    ++i;\n                }\n                if (neg) val = -val;\n                time = val;\n                time_set = true;\n            } else {\n                return false;\n            }\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == ',') ++i;\n        }\n        if (!lat_set || !lon_set || !time_set) return false;\n        points.push_back(Point{lat, lon, time});\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ',') ++i;\n    }\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    return i == input.size();\n}\n\nvoid print_json_array(const std::vector<Point>& points) {\n    std::cout << '[';\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << ',';\n        std::cout << \"{\\\"lat\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << points[i].lat;\n        std::cout << \",\\\"lon\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << points[i].lon;\n        std::cout << \",\\\"time\\\":\";\n        std::cout << points[i].time;\n        std::cout << '}';\n    }\n    std::cout << ']' << std::endl;\n}\n\nvoid detect_anomalies(std::vector<Point>& points) {\n    const double SPEED_THRESHOLD = 50.0; // m/s\n    size_t n = points.size();\n    if (n < 3) return;\n    // Never change first or last point\n    for (size_t i = 1; i + 1 < n; ++i) {\n        double dist_prev = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double dt_prev = points[i].time - points[i-1].time;\n        double speed_prev = (dt_prev > 0) ? dist_prev / dt_prev : 0.0;\n        double dist_next = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double dt_next = points[i+1].time - points[i].time;\n        double speed_next = (dt_next > 0) ? dist_next / dt_next : 0.0;\n        if (speed_prev > SPEED_THRESHOLD || speed_next > SPEED_THRESHOLD) {\n            points[i].anomalous = true;\n        }\n    }\n}\n\nvoid correct_anomalies(std::vector<Point>& points) {\n    size_t n = points.size();\n    if (n < 3) return;\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (points[i].anomalous) {\n            // Use linear interpolation between neighbors\n            double frac = double(points[i].time - points[i-1].time) /\n                          double(points[i+1].time - points[i-1].time);\n            if (frac < 0.0) frac = 0.0;\n            if (frac > 1.0) frac = 1.0;\n            points[i].lat = points[i-1].lat + (points[i+1].lat - points[i-1].lat) * frac;\n            points[i].lon = points[i-1].lon + (points[i+1].lon - points[i-1].lon) * frac;\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    // Read all stdin\n    std::string input, line;\n    while (std::getline(std::cin, line)) {\n        input += line;\n    }\n    std::vector<Point> points;\n    try {\n        if (!parse_json_array(input, points)) {\n            std::cerr << \"Invalid JSON input\\n\";\n            return 1;\n        }\n    } catch (...) {\n        std::cerr << \"Error parsing input\\n\";\n        return 1;\n    }\n    if (points.empty()) {\n        std::cerr << \"Empty input\\n\";\n        return 1;\n    }\n    try {\n        detect_anomalies(points);\n        correct_anomalies(points);\n        print_json_array(points);\n    } catch (...) {\n        std::cerr << \"Error during processing\\n\";\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 7176,
    "compile_time": 1.1302549839019775,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 2,
    "changed_points": 19,
    "time_mismatches": 0,
    "remaining_anomalies": 14,
    "max_speed_violations": 14,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 10
  }
}