{
  "iteration": 4,
  "timestamp": "2025-07-15T17:49:48.950574",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.0690925121307373,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n#include <algorithm>\n\n// Simple JSON parser for array of objects with lat, lon, time (all integers)\nstruct Point {\n    int lat;\n    int lon;\n    int time;\n};\n\nbool is_digit_or_minus(char c) {\n    return std::isdigit(c) || c == '-';\n}\n\nvoid trim(std::string& s) {\n    size_t start = s.find_first_not_of(\" \\t\\r\\n\");\n    size_t end = s.find_last_not_of(\" \\t\\r\\n\");\n    if (start == std::string::npos) {\n        s.clear();\n        return;\n    }\n    s = s.substr(start, end - start + 1);\n}\n\nbool parse_int(const std::string& s, int& out) {\n    try {\n        size_t idx;\n        out = std::stoi(s, &idx);\n        if (idx != s.size()) return false;\n        return true;\n    } catch (...) {\n        return false;\n    }\n}\n\nbool parse_json_array(const std::string& input, std::vector<Point>& points) {\n    size_t i = 0;\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    if (i >= input.size() || input[i] != '[') return false;\n    ++i;\n    while (i < input.size()) {\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ']') {\n            ++i;\n            break;\n        }\n        if (i < input.size() && input[i] == ',') ++i;\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i >= input.size() || input[i] != '{') return false;\n        ++i;\n        int lat = std::numeric_limits<int>::min(), lon = std::numeric_limits<int>::min(), time = std::numeric_limits<int>::min();\n        bool lat_set = false, lon_set = false, time_set = false;\n        while (i < input.size()) {\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == '}') {\n                ++i;\n                break;\n            }\n            // Read key\n            if (i >= input.size() || input[i] != '\"') return false;\n            ++i;\n            size_t key_start = i;\n            while (i < input.size() && input[i] != '\"') ++i;\n            if (i >= input.size()) return false;\n            std::string key = input.substr(key_start, i - key_start);\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i >= input.size() || input[i] != ':') return false;\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            // Read value\n            size_t val_start = i;\n            if (i < input.size() && (input[i] == '-' || std::isdigit(input[i]))) {\n                while (i < input.size() && (std::isdigit(input[i]) || input[i] == '-')) ++i;\n                std::string val = input.substr(val_start, i - val_start);\n                int v;\n                if (!parse_int(val, v)) return false;\n                if (key == \"lat\") { lat = v; lat_set = true; }\n                else if (key == \"lon\") { lon = v; lon_set = true; }\n                else if (key == \"time\") { time = v; time_set = true; }\n                else return false;\n            } else {\n                return false;\n            }\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == ',') ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n        }\n        if (!lat_set || !lon_set || !time_set) return false;\n        points.push_back({lat, lon, time});\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ',') ++i;\n    }\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    return i == input.size();\n}\n\nvoid print_json_array(const std::vector<Point>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << points[i].lat << \",\\\"lon\\\":\" << points[i].lon << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\n// Haversine formula for distance in meters\ndouble haversine(int lat1, int lon1, int lat2, int lon2) {\n    double lat1r = lat1 * M_PI / 1e7 / 180.0 * M_PI;\n    double lon1r = lon1 * M_PI / 1e7 / 180.0 * M_PI;\n    double lat2r = lat2 * M_PI / 1e7 / 180.0 * M_PI;\n    double lon2r = lon2 * M_PI / 1e7 / 180.0 * M_PI;\n    double dlat = lat2r - lat1r;\n    double dlon = lon2r - lon1r;\n    double a = std::sin(dlat/2)*std::sin(dlat/2) + std::cos(lat1r)*std::cos(lat2r)*std::sin(dlon/2)*std::sin(dlon/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return 6371000.0 * c;\n}\n\n// Detect anomalies: speed > 50 m/s (180 km/h) between consecutive points\n// Only change coordinates of such points, never first/last, never change time\nvoid correct_anomalies(std::vector<Point>& points) {\n    if (points.size() < 3) return;\n    std::vector<bool> is_anomaly(points.size(), false);\n\n    // Improved anomaly detection: check both incoming and outgoing speeds\n    for (size_t i = 1; i + 1 < points.size(); ++i) {\n        double dist_prev = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double dt_prev = points[i].time - points[i-1].time;\n        double speed_prev = (dt_prev > 0) ? dist_prev / dt_prev : 0.0;\n\n        double dist_next = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double dt_next = points[i+1].time - points[i].time;\n        double speed_next = (dt_next > 0) ? dist_next / dt_next : 0.0;\n\n        if (speed_prev > 50.0 || speed_next > 50.0) {\n            is_anomaly[i] = true;\n        }\n    }\n    is_anomaly[0] = false;\n    is_anomaly[points.size() - 1] = false;\n\n    // Correction: replace anomalous point with linear interpolation between neighbors\n    for (size_t i = 1; i + 1 < points.size(); ++i) {\n        if (is_anomaly[i]) {\n            int t0 = points[i-1].time, t1 = points[i].time, t2 = points[i+1].time;\n            if (t2 == t0) continue;\n            double alpha = double(t1 - t0) / double(t2 - t0);\n            int new_lat = int(std::round(points[i-1].lat + alpha * (points[i+1].lat - points[i-1].lat)));\n            int new_lon = int(std::round(points[i-1].lon + alpha * (points[i+1].lon - points[i-1].lon)));\n            points[i].lat = new_lat;\n            points[i].lon = new_lon;\n        }\n    }\n}\n\nint main() {\n    try {\n        std::string input, line;\n        while (std::getline(std::cin, line)) {\n            input += line;\n        }\n        trim(input);\n        std::vector<Point> points;\n        if (!parse_json_array(input, points)) {\n            std::cerr << \"{\\\"error\\\":\\\"Invalid JSON input\\\"}\\n\";\n            return 1;\n        }\n        correct_anomalies(points);\n        print_json_array(points);\n    } catch (const std::exception& e) {\n        std::cerr << \"{\\\"error\\\":\\\"Exception: \";\n        std::cerr << e.what();\n        std::cerr << \"\\\"}\\n\";\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points.json",
  "details": {
    "code_size": 6940,
    "compile_time": 1.5046718120574951,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 17,
    "changed_points": 3,
    "time_mismatches": 0,
    "remaining_anomalies": 2,
    "max_speed_violations": 2,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 0
  }
}