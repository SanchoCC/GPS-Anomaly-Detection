{
  "iteration": 13,
  "timestamp": "2025-07-15T17:53:43.015540",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.06849908828735352,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n#include <algorithm>\n\n// Simple JSON parsing utilities for the specific input format\n\nstruct Point {\n    double lat;\n    double lon;\n    int time;\n    bool is_anomaly = false;\n};\n\nbool is_whitespace(char c) {\n    return std::isspace(static_cast<unsigned char>(c));\n}\n\nvoid skip_whitespace(std::istream& in) {\n    while (in && is_whitespace(in.peek())) in.get();\n}\n\nbool parse_null(std::istream& in) {\n    skip_whitespace(in);\n    if (in.peek() == 'n') {\n        std::string s;\n        for (int i = 0; i < 4; ++i) s += static_cast<char>(in.get());\n        return s == \"null\";\n    }\n    return false;\n}\n\nbool parse_string(std::istream& in, std::string& out) {\n    skip_whitespace(in);\n    if (in.get() != '\"') return false;\n    out.clear();\n    char c;\n    while (in.get(c)) {\n        if (c == '\"') return true;\n        if (c == '\\\\') {\n            if (!in.get(c)) return false;\n            if (c == '\"' || c == '\\\\' || c == '/') out += c;\n            else if (c == 'b') out += '\\b';\n            else if (c == 'f') out += '\\f';\n            else if (c == 'n') out += '\\n';\n            else if (c == 'r') out += '\\r';\n            else if (c == 't') out += '\\t';\n            else return false;\n        } else {\n            out += c;\n        }\n    }\n    return false;\n}\n\nbool parse_number(std::istream& in, double& out) {\n    skip_whitespace(in);\n    std::string num;\n    char c = in.peek();\n    if (c == '-' || c == '+') num += static_cast<char>(in.get());\n    while (in && (std::isdigit(in.peek()) || in.peek() == '.')) num += static_cast<char>(in.get());\n    if (num.empty()) return false;\n    try {\n        out = std::stod(num);\n        return true;\n    } catch (...) {\n        return false;\n    }\n}\n\nbool parse_int(std::istream& in, int& out) {\n    skip_whitespace(in);\n    std::string num;\n    char c = in.peek();\n    if (c == '-' || c == '+') num += static_cast<char>(in.get());\n    while (in && std::isdigit(in.peek())) num += static_cast<char>(in.get());\n    if (num.empty()) return false;\n    try {\n        size_t idx;\n        out = std::stoi(num, &idx);\n        return idx == num.size();\n    } catch (...) {\n        return false;\n    }\n}\n\nbool parse_point(std::istream& in, Point& pt) {\n    skip_whitespace(in);\n    if (in.get() != '{') return false;\n    bool lat_set = false, lon_set = false, time_set = false;\n    while (true) {\n        skip_whitespace(in);\n        if (in.peek() == '}') {\n            in.get();\n            break;\n        }\n        std::string key;\n        if (!parse_string(in, key)) return false;\n        skip_whitespace(in);\n        if (in.get() != ':') return false;\n        skip_whitespace(in);\n        if (key == \"lat\") {\n            double v;\n            if (!parse_number(in, v)) return false;\n            pt.lat = v;\n            lat_set = true;\n        } else if (key == \"lon\") {\n            double v;\n            if (!parse_number(in, v)) return false;\n            pt.lon = v;\n            lon_set = true;\n        } else if (key == \"time\") {\n            int v;\n            if (!parse_int(in, v)) return false;\n            pt.time = v;\n            time_set = true;\n        } else {\n            // Skip unknown key\n            if (in.peek() == '\"') {\n                std::string dummy;\n                if (!parse_string(in, dummy)) return false;\n            } else if (in.peek() == '{') {\n                int depth = 1;\n                in.get();\n                while (depth && in.get()) {\n                    if (in.peek() == '{') ++depth;\n                    else if (in.peek() == '}') --depth;\n                }\n            } else {\n                double dummy;\n                parse_number(in, dummy);\n            }\n        }\n        skip_whitespace(in);\n        if (in.peek() == ',') {\n            in.get();\n            continue;\n        } else if (in.peek() == '}') {\n            in.get();\n            break;\n        } else {\n            break;\n        }\n    }\n    return lat_set && lon_set && time_set;\n}\n\nbool parse_points(std::istream& in, std::vector<Point>& out) {\n    skip_whitespace(in);\n    if (in.get() != '[') return false;\n    skip_whitespace(in);\n    while (in && in.peek() != ']') {\n        Point pt;\n        if (!parse_point(in, pt)) return false;\n        out.push_back(pt);\n        skip_whitespace(in);\n        if (in.peek() == ',') {\n            in.get();\n            skip_whitespace(in);\n        } else if (in.peek() == ']') {\n            break;\n        } else {\n            return false;\n        }\n    }\n    if (in.get() != ']') return false;\n    return true;\n}\n\n// Haversine distance (meters)\ndouble haversine(double lat1, double lon1, double lat2, double lon2) {\n    constexpr double R = 6371000.0;\n    double phi1 = lat1 * M_PI / 180.0;\n    double phi2 = lat2 * M_PI / 180.0;\n    double dphi = (lat2 - lat1) * M_PI / 180.0;\n    double dlambda = (lon2 - lon1) * M_PI / 180.0;\n    double a = std::sin(dphi/2)*std::sin(dphi/2) +\n               std::cos(phi1)*std::cos(phi2)*std::sin(dlambda/2)*std::sin(dlambda/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Detect anomalies: speed > 50 m/s, but never first or last point\nvoid detect_anomalies(std::vector<Point>& pts) {\n    const double SPEED_THRESHOLD = 50.0; // m/s\n    size_t n = pts.size();\n    if (n < 3) return;\n    for (size_t i = 1; i+1 < n; ++i) {\n        double d_prev = haversine(pts[i-1].lat, pts[i-1].lon, pts[i].lat, pts[i].lon);\n        int dt_prev = pts[i].time - pts[i-1].time;\n        double d_next = haversine(pts[i].lat, pts[i].lon, pts[i+1].lat, pts[i+1].lon);\n        int dt_next = pts[i+1].time - pts[i].time;\n        double v_prev = (dt_prev > 0) ? d_prev / dt_prev : 0.0;\n        double v_next = (dt_next > 0) ? d_next / dt_next : 0.0;\n        if ((v_prev > SPEED_THRESHOLD || v_next > SPEED_THRESHOLD) &&\n            (dt_prev > 0 && dt_next > 0)) {\n            pts[i].is_anomaly = true;\n        }\n    }\n    pts.front().is_anomaly = false;\n    pts.back().is_anomaly = false;\n}\n\n// Simple correction: interpolate between neighbors\nvoid correct_anomalies(std::vector<Point>& pts) {\n    size_t n = pts.size();\n    for (size_t i = 1; i+1 < n; ++i) {\n        if (pts[i].is_anomaly) {\n            // Linear interpolation between previous and next\n            int t0 = pts[i-1].time, t1 = pts[i+1].time, t = pts[i].time;\n            double ratio = (double)(t - t0) / (t1 - t0);\n            pts[i].lat = pts[i-1].lat + (pts[i+1].lat - pts[i-1].lat) * ratio;\n            pts[i].lon = pts[i-1].lon + (pts[i+1].lon - pts[i-1].lon) * ratio;\n        }\n    }\n}\n\nvoid output_points(const std::vector<Point>& pts) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < pts.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << pts[i].lat;\n        std::cout << \",\\\"lon\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << pts[i].lon;\n        std::cout << \",\\\"time\\\":\";\n        std::cout << pts[i].time;\n        std::cout << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\nint main() {\n    try {\n        // Read entire stdin\n        std::ostringstream oss;\n        oss << std::cin.rdbuf();\n        std::string input = oss.str();\n\n        // Parse JSON\n        std::istringstream iss(input);\n        std::vector<Point> pts;\n        if (!parse_points(iss, pts)) {\n            std::cerr << \"JSON parse error\\n\";\n            return 1;\n        }\n        if (pts.size() < 2) {\n            output_points(pts);\n            return 0;\n        }\n        detect_anomalies(pts);\n        correct_anomalies(pts);\n        output_points(pts);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << \"\\n\";\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 7893,
    "compile_time": 1.2682883739471436,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 2,
    "changed_points": 19,
    "time_mismatches": 0,
    "remaining_anomalies": 14,
    "max_speed_violations": 14,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 10
  }
}