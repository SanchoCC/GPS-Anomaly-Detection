{
  "iteration": 8,
  "timestamp": "2025-07-15T17:51:30.439144",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.06353616714477539,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n\nstruct Point {\n    double lat;\n    double lon;\n    int time;\n    bool anomalous = false;\n};\n\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\ndouble haversine(double lat1, double lon1, double lat2, double lon2) {\n    // Earth radius in meters\n    const double R = 6371000.0;\n    double dlat = deg2rad(lat2 - lat1);\n    double dlon = deg2rad(lon2 - lon1);\n    double a = std::sin(dlat/2) * std::sin(dlat/2) +\n               std::cos(deg2rad(lat1)) * std::cos(deg2rad(lat2)) *\n               std::sin(dlon/2) * std::sin(dlon/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Simple JSON parser for the expected format\nbool skipWhitespace(std::istream& in) {\n    while (in && std::isspace(in.peek())) in.get();\n    return bool(in);\n}\n\nbool expectChar(std::istream& in, char expected) {\n    skipWhitespace(in);\n    if (in.peek() != expected) return false;\n    in.get();\n    return true;\n}\n\nbool parseString(std::istream& in, std::string& out) {\n    skipWhitespace(in);\n    if (in.get() != '\"') return false;\n    out.clear();\n    while (in) {\n        char c = in.get();\n        if (c == '\"') break;\n        if (c == '\\\\') {\n            char next = in.get();\n            if (next == '\"' || next == '\\\\' || next == '/') out += next;\n            else if (next == 'b') out += '\\b';\n            else if (next == 'f') out += '\\f';\n            else if (next == 'n') out += '\\n';\n            else if (next == 'r') out += '\\r';\n            else if (next == 't') out += '\\t';\n            else return false;\n        } else {\n            out += c;\n        }\n    }\n    return true;\n}\n\nbool parseNumber(std::istream& in, double& out) {\n    skipWhitespace(in);\n    std::string numstr;\n    while (in && (std::isdigit(in.peek()) || in.peek() == '-' || in.peek() == '+' || in.peek() == '.' || in.peek() == 'e' || in.peek() == 'E')) {\n        numstr += in.get();\n    }\n    if (numstr.empty()) return false;\n    try {\n        out = std::stod(numstr);\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n\nbool parseInt(std::istream& in, int& out) {\n    skipWhitespace(in);\n    std::string numstr;\n    while (in && (std::isdigit(in.peek()) || in.peek() == '-' || in.peek() == '+')) {\n        numstr += in.get();\n    }\n    if (numstr.empty()) return false;\n    try {\n        size_t idx;\n        out = std::stoi(numstr, &idx);\n        if (idx != numstr.size()) return false;\n    } catch (...) {\n        return false;\n    }\n    return true;\n}\n\nbool parsePoint(std::istream& in, Point& pt) {\n    skipWhitespace(in);\n    if (!expectChar(in, '{')) return false;\n    bool latSet = false, lonSet = false, timeSet = false;\n    for (int i = 0; i < 3; ++i) {\n        skipWhitespace(in);\n        std::string key;\n        if (!parseString(in, key)) return false;\n        skipWhitespace(in);\n        if (!expectChar(in, ':')) return false;\n        if (key == \"lat\") {\n            double val;\n            if (!parseNumber(in, val)) return false;\n            pt.lat = val;\n            latSet = true;\n        } else if (key == \"lon\") {\n            double val;\n            if (!parseNumber(in, val)) return false;\n            pt.lon = val;\n            lonSet = true;\n        } else if (key == \"time\") {\n            int val;\n            if (!parseInt(in, val)) return false;\n            pt.time = val;\n            timeSet = true;\n        } else {\n            return false;\n        }\n        skipWhitespace(in);\n        if (i < 2) {\n            if (!expectChar(in, ',')) return false;\n        }\n    }\n    skipWhitespace(in);\n    if (!expectChar(in, '}')) return false;\n    return latSet && lonSet && timeSet;\n}\n\nbool parseArray(std::istream& in, std::vector<Point>& points) {\n    skipWhitespace(in);\n    if (!expectChar(in, '[')) return false;\n    skipWhitespace(in);\n    if (in.peek() == ']') {\n        in.get();\n        return true;\n    }\n    while (in) {\n        Point pt;\n        if (!parsePoint(in, pt)) return false;\n        points.push_back(pt);\n        skipWhitespace(in);\n        if (in.peek() == ',') {\n            in.get();\n            continue;\n        } else if (in.peek() == ']') {\n            in.get();\n            break;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid printArray(const std::vector<Point>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << std::fixed << std::setprecision(8) << points[i].lat\n                  << \",\\\"lon\\\":\" << std::fixed << std::setprecision(8) << points[i].lon\n                  << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\nvoid detectAnomalies(std::vector<Point>& points, double speed_threshold = 50.0) {\n    size_t n = points.size();\n    if (n < 3) return;\n    // Never mark first or last as anomalous\n    for (size_t i = 1; i + 1 < n; ++i) {\n        double dist_prev = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double dt_prev = points[i].time - points[i-1].time;\n        double speed_prev = (dt_prev > 0) ? dist_prev / dt_prev : 0.0;\n\n        double dist_next = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double dt_next = points[i+1].time - points[i].time;\n        double speed_next = (dt_next > 0) ? dist_next / dt_next : 0.0;\n\n        if (speed_prev > speed_threshold || speed_next > speed_threshold) {\n            points[i].anomalous = true;\n        }\n    }\n    points[0].anomalous = false;\n    points[n-1].anomalous = false;\n}\n\nvoid correctAnomalies(std::vector<Point>& points) {\n    size_t n = points.size();\n    if (n < 3) return;\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (!points[i].anomalous) continue;\n        // Replace with linear interpolation between neighbors\n        int t0 = points[i-1].time;\n        int t1 = points[i+1].time;\n        int t = points[i].time;\n        if (t1 == t0) {\n            points[i].lat = (points[i-1].lat + points[i+1].lat) / 2.0;\n            points[i].lon = (points[i-1].lon + points[i+1].lon) / 2.0;\n        } else {\n            double alpha = double(t - t0) / double(t1 - t0);\n            points[i].lat = points[i-1].lat + alpha * (points[i+1].lat - points[i-1].lat);\n            points[i].lon = points[i-1].lon + alpha * (points[i+1].lon - points[i-1].lon);\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::string input, line;\n    while (std::getline(std::cin, line)) {\n        input += line;\n    }\n    std::istringstream iss(input);\n    std::vector<Point> points;\n    try {\n        if (!parseArray(iss, points)) {\n            std::cerr << \"{\\\"error\\\":\\\"Invalid JSON input\\\"}\\n\";\n            return 1;\n        }\n    } catch (...) {\n        std::cerr << \"{\\\"error\\\":\\\"Exception during parsing\\\"}\\n\";\n        return 1;\n    }\n\n    if (points.empty()) {\n        std::cout << \"[]\\n\";\n        return 0;\n    }\n\n    try {\n        detectAnomalies(points, 50.0);\n        correctAnomalies(points);\n        printArray(points);\n    } catch (...) {\n        std::cerr << \"{\\\"error\\\":\\\"Exception during processing\\\"}\\n\";\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 7376,
    "compile_time": 1.1998894214630127,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 2,
    "changed_points": 19,
    "time_mismatches": 0,
    "remaining_anomalies": 14,
    "max_speed_violations": 14,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 10
  }
}