{
  "iteration": 14,
  "timestamp": "2025-07-15T17:54:05.387677",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.06363105773925781,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n#include <algorithm>\n\n// Simple JSON parser for the specific input format\nstruct Point {\n    int lat;\n    int lon;\n    int time;\n};\n\nbool is_digit_or_minus(char c) {\n    return std::isdigit(c) || c == '-';\n}\n\nbool parse_int(const std::string& s, size_t& idx, int& value) {\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    bool neg = false;\n    if (idx < s.size() && s[idx] == '-') {\n        neg = true;\n        ++idx;\n    }\n    if (idx >= s.size() || !std::isdigit(s[idx])) return false;\n    int val = 0;\n    while (idx < s.size() && std::isdigit(s[idx])) {\n        val = val * 10 + (s[idx] - '0');\n        ++idx;\n    }\n    value = neg ? -val : val;\n    return true;\n}\n\nbool parse_key(const std::string& s, size_t& idx, std::string& key) {\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    if (idx >= s.size() || s[idx] != '\"') return false;\n    ++idx;\n    size_t start = idx;\n    while (idx < s.size() && s[idx] != '\"') ++idx;\n    if (idx >= s.size()) return false;\n    key = s.substr(start, idx - start);\n    ++idx;\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    if (idx >= s.size() || s[idx] != ':') return false;\n    ++idx;\n    return true;\n}\n\nbool parse_point(const std::string& s, size_t& idx, Point& pt) {\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    if (idx >= s.size() || s[idx] != '{') return false;\n    ++idx;\n    bool lat_ok = false, lon_ok = false, time_ok = false;\n    int lat = 0, lon = 0, time = 0;\n    for (int i = 0; i < 3; ++i) {\n        std::string key;\n        if (!parse_key(s, idx, key)) return false;\n        int val = 0;\n        if (!parse_int(s, idx, val)) return false;\n        if (key == \"lat\") { lat = val; lat_ok = true; }\n        else if (key == \"lon\") { lon = val; lon_ok = true; }\n        else if (key == \"time\") { time = val; time_ok = true; }\n        else return false;\n        while (idx < s.size() && std::isspace(s[idx])) ++idx;\n        if (i < 2) {\n            if (idx >= s.size() || s[idx] != ',') return false;\n            ++idx;\n        }\n    }\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    if (idx >= s.size() || s[idx] != '}') return false;\n    ++idx;\n    pt.lat = lat;\n    pt.lon = lon;\n    pt.time = time;\n    return lat_ok && lon_ok && time_ok;\n}\n\nbool parse_json_array(const std::string& s, std::vector<Point>& points) {\n    size_t idx = 0;\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    if (idx >= s.size() || s[idx] != '[') return false;\n    ++idx;\n    while (true) {\n        while (idx < s.size() && std::isspace(s[idx])) ++idx;\n        if (idx < s.size() && s[idx] == ']') { ++idx; break; }\n        Point pt;\n        if (!parse_point(s, idx, pt)) return false;\n        points.push_back(pt);\n        while (idx < s.size() && std::isspace(s[idx])) ++idx;\n        if (idx < s.size() && s[idx] == ',') { ++idx; continue; }\n        else if (idx < s.size() && s[idx] == ']') { ++idx; break; }\n        else if (idx >= s.size()) break;\n        else return false;\n    }\n    while (idx < s.size() && std::isspace(s[idx])) ++idx;\n    return idx == s.size();\n}\n\n// Haversine formula for distance in meters\ndouble deg2rad(double deg) {\n    return deg * M_PI / 180.0;\n}\n\ndouble haversine(int lat1, int lon1, int lat2, int lon2) {\n    double R = 6371000.0;\n    double dlat = deg2rad(lat2 - lat1);\n    double dlon = deg2rad(lon2 - lon1);\n    double a = std::sin(dlat/2) * std::sin(dlat/2) +\n               std::cos(deg2rad(lat1)) * std::cos(deg2rad(lat2)) *\n               std::sin(dlon/2) * std::sin(dlon/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Output JSON array\nvoid print_json_array(const std::vector<Point>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i > 0) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\" << points[i].lat\n                  << \",\\\"lon\\\":\" << points[i].lon\n                  << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\n// Anomaly detection and correction\nvoid correct_gps(std::vector<Point>& points) {\n    if (points.size() < 3) return;\n    const double SPEED_LIMIT = 50.0; // m/s\n    std::vector<bool> is_anomaly(points.size(), false);\n\n    // Mark anomalies (excluding first and last)\n    for (size_t i = 1; i + 1 < points.size(); ++i) {\n        int t0 = points[i-1].time, t1 = points[i].time, t2 = points[i+1].time;\n        if (t1 <= t0 || t2 <= t1) continue; // skip invalid time order\n        double d0 = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double d1 = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double v0 = d0 / (t1 - t0);\n        double v1 = d1 / (t2 - t1);\n        if (v0 > SPEED_LIMIT || v1 > SPEED_LIMIT) is_anomaly[i] = true;\n    }\n    is_anomaly[0] = false;\n    is_anomaly[points.size()-1] = false;\n\n    // Correction: replace anomalous point with linear interpolation of neighbors\n    for (size_t i = 1; i + 1 < points.size(); ++i) {\n        if (is_anomaly[i]) {\n            int t0 = points[i-1].time, t2 = points[i+1].time, t1 = points[i].time;\n            if (t2 == t0) continue; // avoid division by zero\n            double alpha = double(t1 - t0) / (t2 - t0);\n            int new_lat = int(std::round(points[i-1].lat + alpha * (points[i+1].lat - points[i-1].lat)));\n            int new_lon = int(std::round(points[i-1].lon + alpha * (points[i+1].lon - points[i-1].lon)));\n            points[i].lat = new_lat;\n            points[i].lon = new_lon;\n        }\n    }\n}\n\nint main() {\n    // Read all input from stdin\n    std::ostringstream oss;\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        oss << line;\n    }\n    std::string input = oss.str();\n\n    std::vector<Point> points;\n    try {\n        if (!parse_json_array(input, points)) {\n            std::cerr << \"JSON parsing error\\n\";\n            std::cout << \"[]\\n\";\n            return 1;\n        }\n    } catch (...) {\n        std::cerr << \"Exception during parsing\\n\";\n        std::cout << \"[]\\n\";\n        return 1;\n    }\n\n    try {\n        correct_gps(points);\n    } catch (...) {\n        std::cerr << \"Exception during correction\\n\";\n        std::cout << \"[]\\n\";\n        return 1;\n    }\n\n    print_json_array(points);\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points2.json",
  "details": {
    "code_size": 6484,
    "compile_time": 1.1946184635162354,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 9,
    "changed_points": 12,
    "time_mismatches": 0,
    "remaining_anomalies": 4,
    "max_speed_violations": 4,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 6
  }
}