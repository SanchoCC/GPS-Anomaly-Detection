{
  "iteration": 7,
  "timestamp": "2025-07-15T17:51:08.938372",
  "compile_success": true,
  "anomaly_detected": true,
  "correction_success": false,
  "execution_time": 0.0604403018951416,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n#include <algorithm>\n\n// Helper function to trim whitespace\nstd::string trim(const std::string& s) {\n    size_t start = s.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = s.find_last_not_of(\" \\t\\n\\r\");\n    if (start == std::string::npos) return \"\";\n    return s.substr(start, end - start + 1);\n}\n\n// Structure for a GPS point\nstruct GPSPoint {\n    double lat;\n    double lon;\n    int time;\n    bool anomalous = false;\n};\n\n// Parse a JSON array of objects with \"lat\", \"lon\", \"time\"\nbool parse_json_array(const std::string& input, std::vector<GPSPoint>& points) {\n    size_t i = 0;\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    if (i >= input.size() || input[i] != '[') return false;\n    ++i;\n    while (i < input.size()) {\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ']') break;\n        if (i < input.size() && input[i] == ',') ++i;\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i >= input.size() || input[i] != '{') return false;\n        ++i;\n        double lat = std::numeric_limits<double>::quiet_NaN();\n        double lon = std::numeric_limits<double>::quiet_NaN();\n        int time = 0;\n        bool lat_set = false, lon_set = false, time_set = false;\n        while (i < input.size()) {\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == '}') {\n                ++i;\n                break;\n            }\n            // Parse key\n            if (i >= input.size() || input[i] != '\"') return false;\n            size_t key_start = ++i;\n            while (i < input.size() && input[i] != '\"') ++i;\n            if (i >= input.size()) return false;\n            std::string key = input.substr(key_start, i - key_start);\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i >= input.size() || input[i] != ':') return false;\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            // Parse value\n            if (key == \"lat\" || key == \"lon\") {\n                size_t val_start = i;\n                bool negative = false;\n                if (i < input.size() && input[i] == '-') {\n                    negative = true;\n                    ++i;\n                }\n                bool dot_found = false;\n                while (i < input.size() && (std::isdigit(input[i]) || input[i] == '.')) {\n                    if (input[i] == '.') {\n                        if (dot_found) break;\n                        dot_found = true;\n                    }\n                    ++i;\n                }\n                std::string val_str = input.substr(val_start, i - val_start);\n                try {\n                    double val = std::stod(val_str);\n                    if (key == \"lat\") { lat = val; lat_set = true; }\n                    else { lon = val; lon_set = true; }\n                } catch (...) { return false; }\n            } else if (key == \"time\") {\n                size_t val_start = i;\n                bool negative = false;\n                if (i < input.size() && input[i] == '-') {\n                    negative = true;\n                    ++i;\n                }\n                while (i < input.size() && std::isdigit(input[i])) ++i;\n                std::string val_str = input.substr(val_start, i - val_start);\n                try {\n                    int val = std::stoi(val_str);\n                    time = val;\n                    time_set = true;\n                } catch (...) { return false; }\n            } else {\n                return false;\n            }\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i < input.size() && input[i] == ',') ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n        }\n        if (!lat_set || !lon_set || !time_set) return false;\n        points.push_back(GPSPoint{lat, lon, time});\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ',') ++i;\n    }\n    return true;\n}\n\n// Output JSON array in required format\nvoid output_json_array(const std::vector<GPSPoint>& points) {\n    std::cout << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i > 0) std::cout << \",\";\n        std::cout << \"{\\\"lat\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << points[i].lat;\n        std::cout << \",\\\"lon\\\":\";\n        std::cout << std::fixed << std::setprecision(8) << points[i].lon;\n        std::cout << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    std::cout << \"]\\n\";\n}\n\n// Haversine distance in meters\ndouble haversine(double lat1, double lon1, double lat2, double lon2) {\n    const double R = 6371000.0;\n    double phi1 = lat1 * M_PI / 180.0;\n    double phi2 = lat2 * M_PI / 180.0;\n    double dphi = (lat2 - lat1) * M_PI / 180.0;\n    double dlambda = (lon2 - lon1) * M_PI / 180.0;\n    double a = std::sin(dphi/2)*std::sin(dphi/2) +\n               std::cos(phi1)*std::cos(phi2)*std::sin(dlambda/2)*std::sin(dlambda/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Detect anomalies (speed > 50 m/s)\nvoid detect_anomalies(std::vector<GPSPoint>& points) {\n    const double SPEED_LIMIT = 50.0; // m/s\n    size_t n = points.size();\n    if (n < 2) return;\n    for (size_t i = 1; i < n; ++i) {\n        double dist = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        int dt = points[i].time - points[i-1].time;\n        if (dt <= 0) continue; // skip invalid time intervals\n        double speed = dist / dt;\n        if (speed > SPEED_LIMIT) {\n            if (i != 0 && i != n-1) points[i].anomalous = true;\n        }\n    }\n    // Also check backward (for isolated spikes)\n    for (size_t i = 0; i + 1 < n-1; ++i) {\n        double dist = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        int dt = points[i+1].time - points[i].time;\n        if (dt <= 0) continue;\n        double speed = dist / dt;\n        if (speed > SPEED_LIMIT) {\n            if (i+1 != 0 && i+1 != n-1) points[i+1].anomalous = true;\n        }\n    }\n}\n\n// Interpolate anomalous points (linear in lat/lon, time fixed)\nvoid interpolate_anomalies(std::vector<GPSPoint>& points) {\n    size_t n = points.size();\n    if (n < 3) return;\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (!points[i].anomalous) continue;\n        // Find previous non-anomalous\n        size_t prev = i-1;\n        while (prev > 0 && points[prev].anomalous) --prev;\n        // Find next non-anomalous\n        size_t next = i+1;\n        while (next + 1 < n && points[next].anomalous) ++next;\n        if (points[prev].anomalous || points[next].anomalous) continue;\n        int t0 = points[prev].time;\n        int t1 = points[next].time;\n        if (t1 == t0) continue;\n        double ratio = double(points[i].time - t0)/double(t1 - t0);\n        points[i].lat = points[prev].lat + (points[next].lat - points[prev].lat) * ratio;\n        points[i].lon = points[prev].lon + (points[next].lon - points[prev].lon) * ratio;\n    }\n}\n\nint main() {\n    // Read complete input from stdin\n    std::string input, line;\n    while (std::getline(std::cin, line)) {\n        input += line;\n    }\n    input = trim(input);\n    std::vector<GPSPoint> points;\n    try {\n        if (!parse_json_array(input, points)) {\n            std::cerr << \"JSON parse error\\n\";\n            std::cout << \"[]\\n\";\n            return 1;\n        }\n    } catch (...) {\n        std::cerr << \"JSON parse exception\\n\";\n        std::cout << \"[]\\n\";\n        return 1;\n    }\n    if (points.size() < 2) {\n        output_json_array(points);\n        return 0;\n    }\n    // Detect anomalies\n    detect_anomalies(points);\n    // Never change first and last points\n    points.front().anomalous = false;\n    points.back().anomalous = false;\n    // Interpolate only anomalous points\n    interpolate_anomalies(points);\n    // Output\n    output_json_array(points);\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 8196,
    "compile_time": 1.2345092296600342,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 2,
    "changed_points": 19,
    "time_mismatches": 0,
    "remaining_anomalies": 0,
    "max_speed_violations": 0,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 10
  }
}