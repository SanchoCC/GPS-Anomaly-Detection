{
  "iteration": 5,
  "timestamp": "2025-07-15T17:50:19.974811",
  "compile_success": true,
  "anomaly_detected": false,
  "correction_success": false,
  "execution_time": 0.0653836727142334,
  "algorithm_code": "\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <limits>\n#include <cctype>\n#include <algorithm>\n\n// Simple JSON parser for the required format\nstruct Point {\n    double lat;\n    double lon;\n    int time;\n};\n\nbool is_digit_or_minus(char c) {\n    return std::isdigit(c) || c == '-' || c == '.';\n}\n\nstd::vector<Point> parse_json_array(const std::string& input) {\n    std::vector<Point> points;\n    size_t i = 0;\n    while (i < input.size() && std::isspace(input[i])) ++i;\n    if (i >= input.size() || input[i] != '[')\n        throw std::runtime_error(\"Invalid JSON: Expected '[' at start\");\n    ++i;\n    while (i < input.size()) {\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ']') break;\n        if (i < input.size() && input[i] == ',') ++i;\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i >= input.size() || input[i] != '{')\n            throw std::runtime_error(\"Invalid JSON: Expected '{'\");\n        ++i;\n        double lat = std::numeric_limits<double>::quiet_NaN();\n        double lon = std::numeric_limits<double>::quiet_NaN();\n        int time = 0;\n        for (int field = 0; field < 3; ++field) {\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            // Parse key\n            if (i >= input.size() || input[i] != '\"')\n                throw std::runtime_error(\"Invalid JSON: Expected '\\\"' at key\");\n            ++i;\n            size_t key_start = i;\n            while (i < input.size() && input[i] != '\"') ++i;\n            if (i >= input.size())\n                throw std::runtime_error(\"Invalid JSON: Unterminated key\");\n            std::string key = input.substr(key_start, i - key_start);\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (i >= input.size() || input[i] != ':')\n                throw std::runtime_error(\"Invalid JSON: Expected ':' after key\");\n            ++i;\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            // Parse value\n            size_t val_start = i;\n            if (key == \"lat\" || key == \"lon\") {\n                bool negative = false;\n                if (input[i] == '-') ++i;\n                while (i < input.size() && (std::isdigit(input[i]) || input[i] == '.')) ++i;\n                std::string val_str = input.substr(val_start, i - val_start);\n                double val = std::stod(val_str);\n                if (key == \"lat\") lat = val;\n                else lon = val;\n            } else if (key == \"time\") {\n                while (i < input.size() && (std::isdigit(input[i]) || input[i] == '-')) ++i;\n                std::string val_str = input.substr(val_start, i - val_start);\n                time = std::stoi(val_str);\n            } else {\n                throw std::runtime_error(\"Invalid JSON: Unknown key \" + key);\n            }\n            while (i < input.size() && std::isspace(input[i])) ++i;\n            if (field < 2) {\n                if (i >= input.size() || input[i] != ',')\n                    throw std::runtime_error(\"Invalid JSON: Expected ',' between fields\");\n                ++i;\n            }\n        }\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i >= input.size() || input[i] != '}')\n            throw std::runtime_error(\"Invalid JSON: Expected '}' at end of object\");\n        ++i;\n        if (std::isnan(lat) || std::isnan(lon))\n            throw std::runtime_error(\"Invalid JSON: Missing lat/lon\");\n        points.push_back(Point{lat, lon, time});\n        while (i < input.size() && std::isspace(input[i])) ++i;\n        if (i < input.size() && input[i] == ',') ++i;\n    }\n    return points;\n}\n\nstd::string to_json(const std::vector<Point>& points) {\n    std::ostringstream oss;\n    oss << std::fixed << std::setprecision(8);\n    oss << \"[\";\n    for (size_t i = 0; i < points.size(); ++i) {\n        if (i > 0) oss << \",\";\n        oss << \"{\\\"lat\\\":\" << points[i].lat << \",\\\"lon\\\":\" << points[i].lon << \",\\\"time\\\":\" << points[i].time << \"}\";\n    }\n    oss << \"]\";\n    return oss.str();\n}\n\n// Haversine distance in meters\ndouble haversine(double lat1, double lon1, double lat2, double lon2) {\n    static const double R = 6371000.0;\n    double phi1 = lat1 * M_PI / 180.0;\n    double phi2 = lat2 * M_PI / 180.0;\n    double dphi = (lat2 - lat1) * M_PI / 180.0;\n    double dlambda = (lon2 - lon1) * M_PI / 180.0;\n    double a = std::sin(dphi/2) * std::sin(dphi/2) +\n               std::cos(phi1) * std::cos(phi2) *\n               std::sin(dlambda/2) * std::sin(dlambda/2);\n    double c = 2 * std::atan2(std::sqrt(a), std::sqrt(1-a));\n    return R * c;\n}\n\n// Detect anomalies: speed > 50 m/s\nstd::vector<bool> detect_anomalies(const std::vector<Point>& points) {\n    size_t n = points.size();\n    std::vector<bool> anomaly(n, false);\n    if (n < 3) return anomaly;\n    for (size_t i = 1; i + 1 < n; ++i) {\n        double d1 = haversine(points[i-1].lat, points[i-1].lon, points[i].lat, points[i].lon);\n        double dt1 = points[i].time - points[i-1].time;\n        double v1 = (dt1 > 0) ? d1 / dt1 : 0.0;\n        double d2 = haversine(points[i].lat, points[i].lon, points[i+1].lat, points[i+1].lon);\n        double dt2 = points[i+1].time - points[i].time;\n        double v2 = (dt2 > 0) ? d2 / dt2 : 0.0;\n        if (v1 > 50.0 || v2 > 50.0)\n            anomaly[i] = true;\n    }\n    anomaly[0] = false;\n    anomaly[n-1] = false;\n    return anomaly;\n}\n\n// Correct anomalous points using linear interpolation between neighbors\nvoid correct_points(std::vector<Point>& points, const std::vector<bool>& anomaly) {\n    size_t n = points.size();\n    for (size_t i = 1; i + 1 < n; ++i) {\n        if (!anomaly[i]) continue;\n        // Only correct if both neighbors are not anomalous\n        if (!anomaly[i-1] && !anomaly[i+1]) {\n            int t0 = points[i-1].time;\n            int t1 = points[i].time;\n            int t2 = points[i+1].time;\n            if (t2 == t0) continue;\n            double frac = double(t1 - t0) / double(t2 - t0);\n            points[i].lat = points[i-1].lat + frac * (points[i+1].lat - points[i-1].lat);\n            points[i].lon = points[i-1].lon + frac * (points[i+1].lon - points[i-1].lon);\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    // Read complete stdin\n    std::string input, line;\n    while (std::getline(std::cin, line)) {\n        input += line;\n    }\n    try {\n        std::vector<Point> points = parse_json_array(input);\n        std::vector<bool> anomaly = detect_anomalies(points);\n        std::vector<Point> corrected = points;\n        correct_points(corrected, anomaly);\n        std::cout << to_json(corrected) << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"{\\\"error\\\":\\\"\" << e.what() << \"\\\"}\" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n",
  "ai_feedback": "",
  "errors": "",
  "input_file": "points3.json",
  "details": {
    "code_size": 6976,
    "compile_time": 1.4352850914001465,
    "memory_usage": 0,
    "test_cases_passed": 0,
    "binary_size": 0,
    "unchanged_points": 21,
    "changed_points": 0,
    "time_mismatches": 0,
    "remaining_anomalies": 6,
    "max_speed_violations": 6,
    "time_reversals": 0,
    "point_count_match": true,
    "invalid_changes": 0
  }
}